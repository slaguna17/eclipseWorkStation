/*
 *  * generated by Xtext 2.22.0.M2
 */
package edu.upb.lp.isc.generator

import edu.upb.lp.isc.elErrorCosmicoDePaserj.ArithExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.BooleanConstant
import edu.upb.lp.isc.elErrorCosmicoDePaserj.BooleanExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.BooleanOpExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ComparisonExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.Define
import edu.upb.lp.isc.elErrorCosmicoDePaserj.Expression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.FunctionCallExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.IfExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.IntExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListConsOp
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListHeadOp
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListLengthOp
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListOperationExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ListTailOp
import edu.upb.lp.isc.elErrorCosmicoDePaserj.MyRacketProgram
import edu.upb.lp.isc.elErrorCosmicoDePaserj.ParamsExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.StringEqualsExpression
import edu.upb.lp.isc.elErrorCosmicoDePaserj.StringExpression
import java.util.LinkedList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ElErrorCosmicoDePaserjGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
		val MyRacketProgram p = resource.contents.get(0) as MyRacketProgram
		fsa.generateFile("Main.java", generate(p))
	}
	def generate(MyRacketProgram p) '''
		import java.io.*; 
		import java.util.LinkedList; 
		
		
		public class Main {
			public static List getTail (List l){
							l.removeFirst();
							return l;
						}
		public static void main(String[] args) {
			
			«FOR d: p.defines»
				«generateDefine(d)»
			«ENDFOR»
			«FOR e : p.executions»
				«IF e instanceof FunctionCallExpression»«generateFunctionCall(e)» 
				«ELSEIF e instanceof ListExpression»«generateExpression(e)»
				«ELSEIF e instanceof IfExpression»«generateIf(e)»
				«ELSE»System.out.println(«generateExpression(e)»);
				«ENDIF»
			«ENDFOR»
		}
	}'''
	
	def generateExpression(Expression e) {'''
	«IF e instanceof ArithExpression»«generateArith(e as ArithExpression)»
	«ELSEIF e instanceof IntExpression»«generateInt(e as IntExpression)»
	«ELSEIF e instanceof StringExpression»«generateString(e as StringExpression)»
	«ELSEIF e instanceof BooleanExpression»«generateBoolean(e as BooleanExpression)»
	
	«ELSEIF e instanceof ListExpression»«generateList(e as ListExpression)»
	
	«ELSEIF e instanceof IfExpression»«generateIf(e as IfExpression)»
	«ENDIF»'''
		
	}
	def generateDefine(Define d) {
		'''«IF d.body instanceof IntExpression»
			int «d.name» = «generateExpression(d.body)»;
			«ELSEIF d.body instanceof StringExpression»
			String «d.name» = «generateExpression(d.body)»;
			«ELSEIF d.body instanceof BooleanExpression»
			boolean «d.name» = «generateExpression(d.body)»;
			«ELSEIF d.body instanceof ListExpression»
			List «d.name» = new LinkedList «generateExpression(d.body)»;
			«ELSEIF d.body instanceof ArithExpression»
			int «d.name» = «generateExpression(d.body)»;
			«ELSEIF d.body instanceof ListOperationExpression»
				«IF d.body instanceof ListTailOp»
					«d.name».getTail(«d.name»)
				«ELSE»
				«d.name»«generateListOperation(d.body as ListOperationExpression)»
				«ENDIF»;
			«ELSE»
			public static void «d.name» («FOR p : d.params» «generateParams(p)», «ENDFOR»){
				«generateExpression(d.body)»}
				«ENDIF»'''
	}
	
	def generateListOperation(ListOperationExpression l) {
		'''«IF l instanceof ListHeadOp»
				.getFirst()	
			«ELSEIF l instanceof ListConsOp»
				.addFirst(«generateExpression(l.elem)»)
			«ELSEIF l instanceof ListLengthOp»
				.Size()
			«ENDIF»'''
	}
	
	def generateParams(ParamsExpression p){
		'''«p.name»'''
	}
	def generateFunctionCall(FunctionCallExpression e){
		'''«e.function.name»(«e.args.map[generateExpression].join(', ')»)'''
	}
	
	def generateString(StringExpression e) {
		'''«e.st»'''
	}
	
	def generateInt(IntExpression e) '''«e.value»'''
	
	
	def generateArith(ArithExpression e){
	 '''«IF e.op.equals("+")»«e.args.map[generateExpression].join(' + ')»
	 «ELSEIF e.op.equals("-")»«e.args.map[generateExpression].join(' - ')»
	 «ELSEIF e.op.equals("*")»«e.args.map[generateExpression].join(' * ')»
	 «ELSEIF e.op.equals("/")»«e.args.map[generateExpression].join(' / ')»
	 «ENDIF»'''
	 }
	 def generateBoolean(BooleanExpression e){
	 	'''«IF e instanceof BooleanConstant»«e.bool»
	 		«ELSEIF e instanceof BooleanOpExpression»
	 			«IF e.op.equals("OR")»«e.args.map[generateExpression].join(' || ')»
	 			«ELSEIF e.op.equals("AND")»«e.args.map[generateExpression].join(' && ')»
	 			«ENDIF»
	 		«ELSEIF e instanceof ComparisonExpression»
	 			 «IF e.evaluator.equals(">")»«e.args.map[generateExpression].join(' > ')»
	 			 «ELSEIF e.evaluator.equals("<")»«e.args.map[generateExpression].join(' < ')»
	 			 «ELSEIF e.evaluator.equals("equal")»«e.args.map[generateExpression].join(' == ')»
	 			 «ELSEIF e.evaluator.equals("<=")»«e.args.map[generateExpression].join(' <= ')»
	 			 «ELSEIF e.evaluator.equals(">=")»«e.args.map[generateExpression].join(' >= ')»
	 			 «ENDIF»
	 		«ELSEIF e instanceof StringEqualsExpression»
	 			«e.args.map[generateExpression].join('.equals(')» ) 
	 	«ENDIF» '''
	 	//TODO isEmpty
	 }
	 def generateIf(IfExpression e){
	 	'''if(«generateBoolean(e.cond)») {
	 		«generateExpression(e.then)»
	 		}else{
	 		«generateExpression(e.sino)»
	 	}'''
	 }
	 def generateList(ListExpression l){
	 	'''List l = new LinkedList(«generateLinkedList(l.simple.linked as LinkedList)» '''
	 }
	 def generateLinkedList(LinkedList l){
	 	'''«generateExpression(l.head)» 
	 	«FOR t: l.tail»«generateExpression(t)»«ENDFOR»'''
	 }
//	 def generateCond(IfExpression e){
//	 	'''«generateBoolean(e.cond)»'''
//	 }
//	 def generateThen(IfExpression e){
//	 	'''«generateExpression(e.then)»'''
//	 }
//	 def generateSino(IfExpression e){
//	 	'''«generateExpression(e.sino)»'''
//	 }
}
